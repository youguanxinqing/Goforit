# 知识点

Go 有三类测试：功能测试(test)，基准测试(benchmark，性能测试)，示例测试(example)。

一般情况下，一个测试源码文件只会针对与某个命令源码文件，或库源码文件。通常放在一个代码包内。测试源码文件的主名称为前导，并且以“_test”为后缀。

每个测试源码文件**必须**包含一个测试函数。

1. 对测试函数的名称和签名，Go 语言有什么规定？

- 对**功能测试**函数来说，其名称必须以 Test 为前缀，并且参数列表中只应有一个 *testing.T 类型的参数声明。
- 对**性能测试**函数来说，其名称必须以 Benchmark 为前缀，且唯一参数的类型必须是 *testing.B 类型。
- 对**示例测试**函数来说，其名称必须以 Example 为前缀，但对函数的参数列表没有强制规定。

只有测试源码文件的名称正确，测试函数的名称和签名也正确，执行 go test 命令时，测试代码才可能被执行。

go test 运行时，会先做一些准备工作，确定内部需要用到的命令(检查指定代码包的有效性，判断标记是否合法等)。之后，go test 会针对每个被测代码包，依次构建、执行包中符合要求的测试函数，清理临时文件，打印测试结果。

go test 会串行地执行测试流程中的每个步骤。但是为了加快速度，它会并发地对多个被测代码包进行功能测试。但打印结果时，它会依照我们给定的顺序逐个打印。

由于并发测试会让性能测试的结果存在差异，所以性能测试一般都是串行进行的(只有所有构建步骤都做完之后，go test 才会开始执行性能测试)。下一个代码包的性能测试总是在上一个包性能测试完成之后才开始。

2. 怎样解释功能测试的测试结果？

go 命令通常会缓存程序构建的结果，以便将来构建中重用。`go env GOCACHE`命令查看缓存目录的路径。缓存的数据总是能够正确地反映当时的各种源码文件，构建环境，编译器选项等的真实情况。**一旦文件有改动，缓存就会失效。**
- 手动删除所有缓存：`go clean -cache`。
- 手动删除测试缓存：`go clean -testcache`。(不会删除构建结果缓存)
- 设置环境变量 GODEBUG 的值可以改变 go 命令的缓存行为。如：gocacheverify=1 将导致 go 命令绕过任何缓存数据，真正执行并重新生成所有结果，再对比当前结果与缓存结果是否一致。

---
- t.Fail() 程序继续往下执行，但会显示该测试失败信息。(**失败测试的结果，go test 不会进行缓存**)
- t.FailNow() 表示出现错误，测试程序立即停止。
- 如果想在测试失败的同时打印测试日志，可考虑 t.Error() 和 t.Errorf() 方法。
- t.Fatal() 和 t.Fatalf()，打印失败错误日志后立即终止当前测试函数的执行并宣告测试失败。

当测试成功时，go test 不会打印常规日志，除非`go test -v`。

3. 怎样解释性能测试的测试结果？

```go
go test -bench=. -run=^$ [package_path]
```
- `-bench=.` 只有有了这个标记，命令才会进行性能测试。`.`表示执行任意名称的性能测试函数。
- `-run=^%` 表明执行哪些功能测试函数。不加 `-run` 时，执行所有功能测试函数。

最大 P 数量表示运行 goroutine 的逻辑 CPU 的最大个数。runtime.GOMAXPROCS 可以修改最大 P 数量。标记 -cpu 可以设置一个最大 P 数量的列表，供命令在多次测试时使用。

go test 执行性能测试时会有一个正整数，其 `b.N` 表示。go test 会先默认将其设置为 1，然后执行测试函数，如果执行时间没有超过默认上限时间，将 b.N 增大，继续执行，多次往复，直到执行时间 >= 上限时间。最后 b.N 的值会输出在测试结果中。
![](/023/png/78d4c73a9aa9d48b59d3fd304d4b2069.png)