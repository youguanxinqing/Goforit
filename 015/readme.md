# 知识点

传统意义上，指针是一个指向某个确切的内存地址的值，内存地址可以是任何数据或代码的起始地址。

Go 语言中的其他“指针”：
- uintptr，一个数值类型，Go 语言内建数据类型之一。(更接近传统指针)
- unsafe.Pointer，可以**表示任何可寻址**的值的指针，是指针值与 uintptr 转换的桥梁

1. Go 语言中哪些值是不可寻址的？(code: CantAddress)

- 常量的值。
- 基本类型值的字面量。(eg: 123, 12.9,...)
- 算术操作的结果值。
- 对各种字面量的索引表达式和切片表达式的结果值。不过有一个例外，**对切片字面量的索引结果值却是可寻址的**。
- 对字符串变量的索引表达式和切片表达式的结果值。
- 对**字典变量**的索引表达式的结果值。
- 函数字面量和方法字面量，以及对它们的调用表达式的结果值。
- 结构体字面量的字段值，也就是对结构体字面量的选择表达式的结果值。
- 类型转换表达式的结果值。
- 类型断言表达式的结果值。
- 接收表达式的结果值。

不能寻址值的特点：要么**不可变**；要么是**临时结果**，拿到内存地址也没有意义；或者**不安全**。
- 各种对值字面量施加的表达式的求值结果都看做是临时结果。

Go 中有很多表达式，包括：索引表达式，切片表达式，选择表达式(访问某个字段)，调用表达式，类型转换表达式，类型断言表达式，发送表达式或接收表达式(<-mychan, mychan<-)。这些表达式施加在某个值字面量上，一般得到的就是临时结果，都不可以寻址。

`!!!`
- 对数组值、切片值或字典值的**字面量**的表达式会产生临时结果。如果针对的是数组类型或切片类型的**变量**，那么索引或切片的结果值就都不属于临时结果了，可以寻址。
- 对字典类型的变量施加索引表达式，得到的结果值不属于临时结果，但不可以寻址。因为：字典中的每个键-元素对的存储位置都可能会变化，而且这种变化外界是无法感知的。(当满足一定条件时，字典可能会改变哈希桶的数量，并适时地把其中的键-元素对搬运到对应的新的哈希桶中)
- 对函数或方法不可寻址，因为这样做不安全。

>最后总结：
>1. 不可变的值不可寻址。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。其实这样规定也有安全性方面的考虑。
>2. 绝大多数被视为临时结果的值都是不可寻址的。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。
>3. 若拿到某值的指针可能会破坏程序的一致性，那么就是不安全的，该值就不可寻址。由于字典的内部机制，对字典的索引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。

PS：把临时结果赋给一个变量，那么它就可以被寻址了。

2. 不可寻址的值在使用上有什么限制？

- 不能对其使用 & 操作符。
- 不能以链式的方式调用指针方法：
```go
type Dog struct {
    ...
}

func (d *Dog) Name {
    ...
}

func New() Dog {
    return Dog{...}
}

func main() {
    New().Name()  // error ,不能这样使用
}
```
- 不能对其使用 ++、--，要求使用两个操作符左边的值是可以寻址的。例外：字典字面量和字典变量索引表达式的结果值。
- range 关键字左边的表达式的结果是必须是可寻址的。列外：字典索引结果值。

3. 怎样利用 unsafe.Pointer 操作可寻址的值？

```go
dog := Dog{"little pig"}
dogP := &dog
dogPtr := uintptr(unsafe.Pointer(dogP))

namePtr := dogPtr + unsafe.Offsetof(dogP.name)
nameP := (*string)(unsafe.Pointer(namePtr))
```
- 一个指针值（比如*Dog类型的值）可以被转换为一个 unsafe.Pointer 类型的值，反之亦然。
- 一个 uintptr 类型的值也可以被转换为一个 unsafe.Pointer 类型的值，反之亦然。
- 一个指针值无法被直接转换成一个 uintptr 类型的值，反过来也是如此。