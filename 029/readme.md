# 知识点

同一时刻，只会有少数的 goroutine 真正处于运行状态，这个数量与 M 的数量一致。

互斥锁可以保证临界区的代码串行执行，但不能保证这些代码执行的**原子性**(atomicity)。

真正能够保证原子性执行的只有**原子操作**（atomic operation）。原子操作在进行过程中不允许中断。在底层，这会由 CPU 提供芯片级别的支持，即使在多 CPU 核心，或者多 CPU 的计算机系统中，也是如此。

原子操作可以完全消除竞态条件，绝对保证并发安全，执行速度比其他同步工具快很多。**缺点是**，操作系统层面**只对针对二进制位或整数**的原子操作提供了支持。

Go 语言的原子操作函数都在 sync/atomic 中。

1. sync/atomic 包中支持哪些原子操作，可操作的数据类型有哪些？

- 支持操作：加法（add），比较交换（compare and swap，简称：CAS），加载（load），存储（store），交换（swap）。
- 支持类型：int32，int64，uint32，uint64，uintptr，unsafe 中的 Pointer(对 Pointer 不支持原子加法操作)；**sync.Value** 支持存储任意类型。

2. 用原子操作可以实现减法操作吗？

可以，具体实现方式见：AtomicSubNum。

- 方法1：例如对 -3 操作做类型转换 -> uint32(int32(-3))。此时编译器会报错，但可以绕过编译器的检查：
```go
delta = int32(-3)
subNUm := uint32(delta)
```

- 方法2：
```go
^uint32(-N-1))

-------
解析：
N -> -3
-N - 1 -> 2
2(int) -> 0000 0000 0000 0000 0000 0000 0000 0010 -> 
```
(暂时没想明白这是啥意思)

3. 比较交换与交换有什么不同，优势在哪里？

交换是指，把新值赋给变量，返回变量的旧值。