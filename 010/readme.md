# 知识点

>不要通过内存共享来通信，应该通过通信共享内存。

**通道类型的值本身就是并发安全**(Go 语言自带的、唯一一个可以满足并发安全性的类型)。

创建与使用：
```go
func main() {
	intChan := make(chan int, 8) // cap = 8
	intChan <- 1
	intChan <- 2
	fmt.Println(<-intChan)

}
```

当容量为 0 时，通道称为**非缓冲通道**。否则叫作**缓冲通道**。(一个通道相当于 FIFO 队列)

1. 对通道的发送与接收操作都有哪些基本特定？

- **对同一个通道，发送操作之间是互斥的，接收操作之间也是互斥**。

同一个时刻，Go 运行时系统只会执行对同一个通道的任意个发送操作中的一个。直到元素完全被复制进该通道之后，其他针对该通道的发送操作才可能被执行。

注意，元素值从外界进入通道时会被复制，即，进入通道的数据是元素的副本。

- **发送操作和接收操作中对元素值的处理都是不可分割的**。

元素从通道进入外界时会被移动。包含两个步骤：
1. 生成正在通道中的元素值的副本，并准备给接收方。
2. 删除在通道中的这个元素值。

整个过程不可分割，绝不会被打断。

- **发送操作在完全完成之前会被阻塞，接收操作也是**。

发送操作包括“复制元素值”和“放置副本到通道内部”两个操作，在这两个动作完成之前，代码会一直阻塞发送那段代码处。

接收操作包含了“复制通道里的元素”“放置副本到接收方”“删除原值”三个步骤。

**阻塞代码是为了实现操作的互斥和元素值的完整。**

2. 发送操作和接收操作什么时候可以被长时间的阻塞？

当通道满的时候，对它的所有发送操作都会被阻塞，直到通道中有的元素被接收走。之后通道会优先通知最早因此等待的、那个发送操作所在的 goroutine，让它再次执行发送操作。

对**非缓冲通道**，不论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。并且，数据是直接从发送方赋值到接收方的，中间并不会用缓存通道做中转。

**缓冲通道**用异步方式传递数据。当发送操作在执行时，发现空的通道中正好有等待的接收操作，那么它会直接把元素复制给接收方。

对 nil 的通道，不论它的具体类型是什么，对它发送操作和接收操作都会永久的处于阻塞状态。其所属 goroutine 中的任何代码都不会被执行。（由于通道是引用类型，所以它的零值就是 nil）(code: NilChan)
```go
var ch3 chan int
//ch3 <- 1 // 通道的值为nil，因此这里会造成永久的阻塞！
//<-ch3 // 通道的值为nil，因此这里会造成永久的阻塞！
_ = ch3
```

3. 发送操作和接收操作什么时候会引发 panic?

**一个已经初始化，但并未关闭的通道，收发操作一定不会引发 panic。**但是通道一旦关闭，再对它进行**发送**操作，就会引发 panic。如果关闭已经关闭的通道，也会引发 panic。（接收操作可以感知到通道的关闭，并能够安全退出）(code: CloseChan)

**如果通道关闭，但里面还有元素未取出，则接收方的第一个变量是通道中的元素值，第二个变量还是 true。**因此通过接收方来判断通道是否已经关闭会有延迟。

如果没有特殊要求，不应该让接收方关闭通道，而应该让发送方做这件事。

------
Go 语言中没有深拷贝？！