# 知识点 
 
数组与切片的区别：
- 数组(array)的长度不可变，切片(slice)的长度可变
- 数组的长度必须在声明的时候给定，以后就不能改变。长度是数组类型的一部分，`[1]string` 和 `[2]string` 是两种不同的数组类型
- 切片类型不用给定长度，切片的长度可以自动地随着元素增加而增加，但不会随着元素减少而减少

![array_vs_slice](/007/png/edb5acaf595673e083cdcf1ea7bb966c.png)

每个切片底层数据结构中，一定包含一个数组。**切片可以被看作是对数组的某个连续片段的引用**。
>因此，Go 语言中切片类型属于引用类型。同属于引用类型的还有：字典类型，通道类型，函数类型...数组在 Go 中属于值类型，同属值类型的有基础数据类型，结构体类型。

通过调用 len() 可以获得数组与切片的长度，调用 cap() 获得它们的容量。**数组的长度总是等于它的容量，且都不可变。**切片的容量变化则有迹可循。


1. 如何估算切片的长度和容量？

用 make() 可以创建一个切片对象：
```go
s1 := make([]int, 5)  // len = 5, cap = 5
s2 := make([]int, 5, 8)  // len = 5, cap = 8
```
- 使用 make() 初始化切片时，如果不指明容量，那么容量 = 长度
- **切片的容量实际上代表了它的底层数组的长度**(仅限于使用 make 函数或者切片值字面量初始化切片的情况)

切片的更通用规则：**一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数**。
```go
s3 := []int{1, 2, 3, 4, 5, 6, 7, 8}
s4 := s3[3:6]
fmt.Printf("The capacity of s3: %d\n", cap(s3))  // cap = 8
fmt.Printf("The length of s4: %d\n", len(s4))  // len = 3, 表示当前可看到个数
fmt.Printf("The capacity of s4: %d\n", cap(s4))  // cap = 5, 表示可以看到的最大个数
fmt.Printf("The value of s4: %d\n", s4)
```
![](/007/png/96e2c7129793ee5e73a574ef8f3ad755.png)

在 s3 的基础之上，构建了一个 s4 的切片，因而 s3 底层数组也是 s4 的底层数组。此时 s3 的 cap=8