# 知识点

当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在**竞态条件**。

导致竞态条件发生的代码区称作**临界区**。临界区要求，在该代码片段下，需要对共享资源实现串行化访问。如果针对同一个资源，这样的代码片段存在多个，就称它们为相关临界区。

**共享数据的一致性的意义**：多个线程对共享数据的操作总是可以达到它们各自预期的效果。

同步的意义：
- 避免多个线程在同一时刻操作同一个数据块。
- 协调多个线程，避免它们同一时刻执行同一个代码块。

常用的同步工具是**互斥锁**，mutual exclusion mutex。互斥锁可以保证，在同一时刻，只会有一个 goroutine 处于该临界区之内。

1. 使用互斥锁的注意事项？

- 不要重复锁定互斥锁。
- 不要忘记解锁互斥锁（考虑 defer）。
- **不要对尚未锁定或者已经解锁的互斥锁解锁**。
- 不要在多个函数之间直接传递互斥锁。

对一个已经被锁定的互斥锁进行锁定，会立即阻塞当前的 goroutine。所谓死锁，就是当前程序中的主 goroutine，以及用户启动的 goroutine 都被阻塞了。(code: DeadLine)
```go
func main() {
	lock := sync.Mutex{}
    fmt.Println("start lock")
    // 错误示例
	lock.Lock()
	lock.Lock()
}
```
- `fatal error: all goroutines are asleep - deadlock!`
- 这种错误不可恢复，即：一旦产生死锁，程序必然崩溃。

如果一个流程在锁定某个互斥锁之后分叉了，或者有被中断的可能，则建议使用 defer 语句对其解锁。

由于 sync.Mutex 是结构体类型，因此传递给函数，从函数中返回、将其赋值给其他变量、进入通道，都会产生副本。副本与原值之间完全独立，它们是不同的互斥锁。

2. 读写锁与互斥锁有哪些异同？

sync.RWMutex 是读写锁。一个读写锁包含读锁和写锁，sync.RWMutex 中的 Lock、Unlock 对写锁起到锁定和解锁的功能；RLock、RUnlock 对读锁起到锁定和解锁的功能。

对一个读写锁来说，有以下规则：
- **写锁**被锁定的情况下，**再锁定写锁**，**阻塞**当前 goroutine。
- **写锁**被锁定的情况下，**再锁定读锁**，**阻塞**当前 goroutine。
- **读锁**被锁定的情况下，**再锁定写锁**，**阻塞**当前 goroutine。
- **读锁**被锁定的情况下，**再锁定读锁**，**不阻塞**当前 goroutine。