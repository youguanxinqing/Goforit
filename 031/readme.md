# 知识点

并发同步工具：WaitGroup，并发安全，一旦被使用就不能被复制。
- Add
- Done( Done 的内部实际是调用了 `wg.Add(-1)` )
- Wait：当计数器不为 0 时，会阻塞当前 goroutine；当计数器为 0 时，什么也不做。
(code: UseWaitGroup)

1. WaitGroup 中的计数器可以小于 0 吗？

**不可以。**因为会引发 panic。

>如果对它的 Add 方法的首次调用，与对它的 Wait 方法的调用是同时发起的，比如，在同时启用的两个 goroutine 中，分别调用这两个方法，那么就有可能会让这里的Add方法抛出一个 panic。
(code: AddAndWait, 未能复现上述 panic)

WaitGroup 值可以被复用，但需要保证其计数周期的完整性(一个周期：0 -> n -> 0)。

如果 Wait() 执行期间跨越了两个计数周期，引发 panic。(即：当 Wait() 正处于唤醒期间时，又调用了 Add，此时 Wait 抛 panic)

建议：**不要把增加其计数器值的操作和调用其Wait方法的代码，放在不同的 goroutine 中执行。换句话说，要杜绝对同一个WaitGroup值的两种操作的并发执行**。

2. sync.Once 类型值的 Do 方法如何保证只执行参数函数一次？

sync.Once 是结构体类型，并发安全。**该类型包含一个 sync.Mutex 类型字段，因此复制该类型的值会导致功能失败**。

Once 类型的 Do 方法只接收一个参数，参数类型必须是 func()，即：无参声明和结果声明的函数。
- Do 只会执行**首次传入的函数**，之后传入的函数都不会执行。
- 是否执行过函数被记录在 Once 类型中的 done (uint32)字段，只可能是 0 或者 1。
- 是否执行过函数会有两重判断。第一次在临界区外(称**快路径**)，第二次在临界区内(**慢路径**)。

Do 方法的功能特点：
- Do 方法是在参数函数执行结束之后，将 done 字段变为 1。因此，当函数十分耗时时，其他 goroutine 都会因为调用了 Do 方法而被阻塞。造成相关 goroutine 同时阻塞。
- done 的 =1 操作是在 defer 中执行的，因此不论函数执行成功与否，done 都会变为 1。

Once 类型使用互斥锁和原子操作实现了功能，而 WaitGroup 类型中只用到了原子操作。