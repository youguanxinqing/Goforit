# 知识点

在 Go 语言规范中，为避免歧义，键值对被称做“键-元素对”。

1. 为什么 Go 语言中的键类型会受到约束。

Go 语言中的字典类型是一个哈希表的特定实现，在实现中，键和元素最大的不同是，键类型是受限的，元素却可以是任意类型。

判断一个某个键是否在字典中，可用以下方法：
```go
var myMap = map[string]int {
    "one": 1,
    "two": 2,
    "three": 3,
}

if v, ok := myMap["two"]; ok {
    ...
}
```

哈希表查找元素过程：
- 用哈希函数将键值转换为哈希值（通常是一个无符号整数）。一个哈希表会持有一定数量的桶（bucket），哈希桶会均匀储存所属哈希表收纳的键-元素对。
- 哈希表先用键哈希值的低几位去定位到一个哈希桶，然后再去这个哈希桶中查找这个键。
- 如果找到了键值(哈希形式存在)，再用键值本身对比一次，这是为了避免“哈希碰撞”。所以键值必须支持判等。

在 Go 语言的字典中，每一个键值都由它的哈希值代表，**字典不会独立存储任何键的值，但会独立存储他们的哈希值。**

Go 语言规范中，字典的键值类型**不可以是函数类型，字典类型，切片类型**。键类型的值之间必须支持操作符 ==、!=(键类型必须支持判等，函数类型、字典类型、切片类型的值不支持判等操作)。(code: SliceAsKey, MultiDimension)
```go
var badMap = map[interface{}]int{
    "1":      1,
    []int{2}: 2, // 编译器不会报错，语法上认同该做法，但运行报错
    3:        3,
}
```
- **最好不要把字典的键类型设定为任意接口类型。**
- 如果键的类型是结构体类型，则需要保证其中字段的类型都是合法的。

# 二维数组形式 补充
```go
x := [2][3]string{
    {"1", "2", "3"},
    {"1", "2", "3"},
}
```

2. 应该优先考虑哪些类型作为字典的键类型？

总的说：**求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。**

以求哈希的操作为例，宽度越小的类型速度通常越快。对布尔类型，整数类型，浮点数类型，复数类型和指针类型来说都是如此。对字符串类型，由于宽度不定，所以需要根据它的具体长度判断，长度越短求哈希越快。(类型的长度是指它占用的字节数。bool int8 uint8 类型的一个值需要占用的字节数都是1，则宽度为 1)

对于数组类型，哈希实际上是依次求得它的每个元素的哈希值并进行合并，所以速度取决于它的元素类型以及长度。

结构体类型，哈希就是对它的每个字段求哈希值并合并，所以速度取决于它的字段个数与字段类型。

**对于接口类型**，具体的哈希算法由值的实际类型决定。接口类型作为键类型是最危险的。

所以，**通常来说**，优先选择数值类型和指针类型。如果非要选择字符串类型，最好对键值长度有额外约束。**不通常来说**，Go 语言有时会对字典的增、删、改、查操作做一些优化。比如字典的键类型为字符串类型，再比如键类型的宽度为 4 或 8 的整数类型情况下。

3. 值为 nil 的字典上执行读写操作会成功吗？(code: NilMap)

字典是引用类型，所以仅声明而不初始化一个字典类型的变量时，它的值是 nil。
```go
var m map[string]int
fmt.Println(m == nil)  // true
```
对一个值为 nil 的字典做任何操作都不会引起错误，除了往 nil 的字典中添加键-元素对。
```go
m["zhong"] = 512  // panic，运行是发生，能够通过编译
```

# map 是兵法安全的吗？ 补充
不是。

判断一个操作是否是原子的，可以使用 `go run race` 做检测。