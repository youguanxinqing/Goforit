# 知识点

goroutine 代表着并发编程模型中的用户级线程。

在操作系统中，**除主线程之外**其他线程都只能由代码**显式地创建和销毁**。但在 Go 语言中，Go 的运行时系统会自动创建和销毁系统级的线程。

用户级线程则由使用者控制代码的执行流程。其创建、销毁、调度、状态变更以及其中的代码和数据都完全需要我们的程序自己去实现和处理。

Go 有独特的并发编程模型，用户级线程（goroutine），用于调度 goroutine、对接系统级线程的调度器。
- 运行时系统组成部分：G(Goroutine)、P(Processor)、M(Machine)。
- M 表示系统级线程，P 承载若干个 G，且使得 G 与 M 正常对接，得到真正运行的中介。
- G 与 M 因为 P 的存在呈现多对多关系。
![](/016/png/9ea14f68ffbcde373ddb61e186695d7d.png)

>当一个正在与某个 M 对接并运行着的 G，需要因某个事件（比如等待 I/O 或锁的解除）而暂停运行，调度器总会及时发现，并把这个 G 与那个 M 分离开，以释放计算资源供那些等待运行的 G 使用。
>当一个 G 需要恢复运行时，调度器又会尽快为它寻找空闲的计算资源（包括 M）并安排运行。当 M 不够用时，调度器会向操作系统申请新的系统级线程，而当某个 M 已无用时，调度器又会负责把它及时地销毁掉。

1. 什么是什么是主 goroutine，与我们启用的其他 goroutine 有什么不同？

```go
func main() {
	for i:=0; i < 10; i++ {
		go func() {
			fmt.Println(i)
		}()
	}
}
```
- 问：程序会打印什么？
- 答：什么都不输出。
- 原因：非干预情况下，主 goroutine 不会等其他 goroutine 执行完，该结束的时候就会结束。主 goroutine 执行结束后，程序就会结束运行。

(
当程序执行到一条 go 语句的时候，会先试图从某个存放空闲的 G 的队列中获取一个 G（goroutine），如果没有空闲的，就创建一个新的 G。拿到 G 之后，运行时系统会将 G 去包装当前的 go 函数，然后将这个 G 追加到某个存放可运行的 G 的队列中。该队列总是先入先出顺序。
)

2. 如何让主 goroutine 等待其他 goroutine？

通道方式解决。（code: WaitGoroutineByChan）
- 作为信号传输的时候，通常建议使用 struct{}，对应**类型值的表示只有一个 struct{}{}**。
- struct{}{} 占用内存空间 0 字节，这个值 Go 程序中永远只会存在一份。

3. 如何让 goroutine 按照既定的顺序运行？(code: OrderedGoroutine)