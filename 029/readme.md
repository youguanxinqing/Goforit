# 知识点

同一时刻，只会有少数的 goroutine 真正处于运行状态，这个数量与 M 的数量一致。

互斥锁可以保证临界区的代码串行执行，但不能保证这些代码执行的**原子性**(atomicity)。

真正能够保证原子性执行的只有**原子操作**（atomic operation）。原子操作在进行过程中不允许中断。在底层，这会由 CPU 提供芯片级别的支持，即使在多 CPU 核心，或者多 CPU 的计算机系统中，也是如此。

原子操作可以完全消除竞态条件，绝对保证并发安全，执行速度比其他同步工具快很多。**缺点是**，操作系统层面**只对针对二进制位或整数**的原子操作提供了支持。

Go 语言的原子操作函数都在 sync/atomic 中。

1. sync/atomic 包中支持哪些原子操作，可操作的数据类型有哪些？

- 支持操作：加法（add），比较交换（compare and swap，简称：CAS），加载（load），存储（store），交换（swap）。
- 支持类型：int32，int64，uint32，uint64，uintptr，unsafe 中的 Pointer(对 Pointer 不支持原子加法操作)；**sync.Value** 支持存储任意类型。

2. 用原子操作可以实现减法操作吗？

可以，具体实现方式见：AtomicSubNum。

- 方法1：例如对 -3 操作做类型转换 -> uint32(int32(-3))。此时编译器会报错，但可以绕过编译器的检查：
```go
delta = int32(-3)
subNUm := uint32(delta)
```

- 方法2：
```go
^uint32(-N-1))

-------
解析：
N -> -3
-N - 1 -> 2
2(int) -> 0000 0000 0000 0000 0000 0000 0000 0010 -> 1111 1111 1111 1111 1111 1111 1111 1101(补码)
       -> 1000 0000 0000 0000 0000 0000 0000 0011 -> -3 

```
(暂时没想明白这是啥意思)

3. 比较交换与交换有什么不同，优势在哪里？

交换是指，把新值赋给变量，返回变量的旧值。

CAS 操作时，函数会判断被操作变量的当前值，如果与我们预期的值相同，则把预期值赋给被操作的变量，最后返回 true。否则忽略交换操作，直接返回 false。(atomic.CompareAndSwapInt32() 返回 bool 类型)

借助 CAS，实现自旋锁：
```go
for {
    if atomic.CompareAndSwapIn32(...) {
        break
    }
    time.Sleep(time.Millisecond * 30)
}
```
- 类似互斥锁操作。
- 满足某个条件后，跳出循环。
- 互斥锁使用场景：共享资源状态被其他 goroutine 频繁改变。
- for + CAS 使用场景：共享资源不会频繁改变，或者，共享资源的状态总会变成期望那样。

4. 读操作有必要使用原子操作吗？

有必要，确保上一次程序中的数据被正常操作完。

5. 怎样用好 sync/sync.Value？

注意，一旦 sync.Value 类型的值被真正使用(即，用来承载了数据)，它就不应该被赋值。

强制性规则：
- 不能用原子值存储 nil。(**如果是接口类型，动态值是 nil，但动态类型不是 nil，则认为它的值不是 nil**)
- 向原子值存储的第一个值，决定了它今后能且只能存储这一个类型的值。(在内部，根据被存储值的实际类型做判断)

!!!:
无法通过某个方法获知一个原子值是否已经被真正使用，并且，也没有办法通过常规的途径得到一个原子值可以存储值的实际类型。

对此，应该遵守使用建议：
- 不要把内部使用的原子值暴露给外界。变量的访问权限至少应该是包级私有。
- 通过函数方式，让外界间接使用原子值。总之，不要把原子值传递到外界。
- 当函数向内部的原子值存储值时，先判断类型是否合法。避免引发 panic。
- 将原子值封装在结构体中。
- **尽量不要向原子值中存储引用类型的值。这很容易造成安全漏洞。**

```go
var box6 atomic.Value
v6 := []int{1, 2, 3}
box6.Store(v6)
v6[1] = 4 // 注意，此处的操作不是并发安全的！
```